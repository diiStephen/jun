match' :: Term -> Term -> Maybe Subst 
applyLifted :: Subs -> Term -> Term 

(applyLifted . ( match' l s)) r

( a - > b) -> M a -> M b 

maybe :: b -> ( a -> b) -> M a -> b 

f = (maybe Rewrite.id (applyLifted) (match' l s)) 

b == (Term -> Maybe a)
(a -> b) == Subst -> (Term -> Maybe Term) 
M a == Maybe Subst 

Get the Id function OR a substitor

f l if f == id else f r 

b ~ Term = l 
(a -> b) ~ _ -> Term 


--rewrite2 :: (Term, Term) -> Term -> Term 
rewrite2 (l,r) s = (maybe (\x -> Nothing) (applyLifted) (match' l s)) 

{-
Any advantages here?
Not really as there is, e.g. no recursion passing the same arguments to the function between recursive calls. 
-}
rewrite2 :: (Term,Term) -> Term -> Maybe Term
rewrite2 (l,r) = go 
    where 
        go s = run 
            where 
                run = case match' l s of 
                    Just sigma -> Just (applyLifted sigma r)
                    Nothing -> Nothing 


{-
Can we use GADTs to make this better?
Ans: Probably not, there are no type variables involved here. 
-}
data GTerm a where 
    GV :: GTerm VName 
    GT :: String -> [GTerm a] -> GTerm a

---
Parser for terms 
Ideas:
    1. Make the sigature ranked to ensure that each function symbol is apploed 
    to the correct number of subterms. 

    2. Empty terms? 
E.g. 

f(a,b,g(x,y)) -> 

T f [
        T a [], 
        T b [],
        T g [
            V (x,1),
            V (y,1)
        ] 
    ]

g \in Sig
parse g(x) ~> T g [V (x,1)]

--- 
g(x,y) ~> T "g" [V ("x", 1), V("y", 1)]


--- 
parse "g(f(x), f(a))"
sig = ["g", "f", "a"]

parse functionSymbol 'g' -> T "g" []

--

{-space :: Parser () 
space = do 
    many (sat isSpace)
    return ()  
-}


{-sat :: (Char -> Bool) -> Parser Char 
sat pred = do 
    x <- item 
    if pred x then return x else empty 
-}


{-string :: [Char] -> Parser [Char]
string [] = return []
string (x:xs) = do 
    char x 
    string xs
    return (x:xs)
-}


{-symbol2 :: [Char] -> Parser [Char]
symbol2 xs = token (string xs)
-}

---
p :: Parser a 
s :: Parser s 
many (s >> p) :: Parser [a]

sep1 p s = do 
    first <- p 
    rest <- many (s >> p)
    return (first:rest)

sep2 p s = p >>= (\ first -> 
    many (s >> p) >>= (\ rest -> 
        pure (first:rest)))

--

{--example = sep (symbol "hello") (symbol ",")
s = parse example "hello,hello,hello,world"
--}

--- 

<*> :: f (a -> b) -> f a -> f b 
<$> :: (a -> b)   -> f a -> f b 


V :: (String, Int) -> Term 
(,) :: a -> b -> (a, b)



want - a -> b -> Term  

var :: [Char] -> Parser Term 
var s = symbol s >>= (\sym -> pure (V (sym, 1)))


--- 

f(t1, t2, ..., tn)
x

---
symbol "(" *> sep (many (sat (/= ')'))) (symbol ",") <* symbol ")"